[
  {
    "mento_seed_question": "효과적인 IT 개발 공부 방법이 궁금합니다.",
    "mento_seed_answer": "개발을 효과적으로 학습하는 가장 좋은 방법은 책이나 영상 강의만 보는 것이 아니라, 직접 무언가를 만들어보는 것. 단순히 개념을 이해하는 것에서 끝나는 것이 아니라, 직접 프로젝트를 진행하면서 개념을 체득하는 방식이 훨씬 더 강력한 학습 효과를 가져옴",
    "mento_seed_id": "457273670840592775"
  },
  {
    "mento_seed_question": "멘토님의 개발 공부 방법은 어떻게 되시나요?",
    "mento_seed_answer": "책, 영상만 보는게 아니라 직접 무언가를 만들어보는게 중요. 개념을 이해하는 것에서 끝나는 것이 아니라, 직접 프로젝트를 진행하면서 개념을 체득하는 방식이 훨씬 더 오래 기억에 남기도 함.",
    "mento_seed_id": "457273670840594249"
  },
  {
    "mento_seed_question": "좋은 블로그 글 작성하는 기준",
    "mento_seed_answer": "트러블슈팅(문제 원인 파악 및 문제 해결 과정) 위주로 작성, 취업용으로 접근 X, 내가 남한테 내 지혜를 공유한다는 관점으로 작성하면 좋음, 문장 정제하는 연습 하다보면 말할 때 연습도 잘 됨",
    "mento_seed_id": "457273670840594289"
  },
  {
    "mento_seed_question": "«코드» 적합성 평가받고 싶습니다.",
    "mento_seed_answer": "코드, 개발에 있어서 \"정답\" (모범답안)은 존재하지 않는다.",
    "mento_seed_id": "457273670840594299"
  },
  {
    "mento_seed_question": "개발자 취준생이 신입 개발자로 취직하기 위하여 어떤 자세, 태도, 목표로 공부해야 하는지 알고 싶다.",
    "mento_seed_answer": ": 항상 내 실력에 겸손하고 배우려는 자세를 취할 것 : 단, 너무 자신감 없는 태도는 X, 자신감은 가질 것 : 목표는 항상 자기 자신과 비교하면서 어제의, 저번 달의, 1년 전의 나보다 더 잘하겠다는 목표로 할 것 : 국비 부트캠프 과정에서 취할 수 있는 것이 '내가 이런 것들을 만들 수 있다'라는 것을 보여줄 수 있는 것인데, 이런 부분들을 만족시킬 수 있는 입사 전형이 '사전 과제' 전형 알고리즘 등 CS로 승부 보기에는 많은 노력이 필요할 것 라이프 사이클이 빠른 기업(예: 토스, 당근 등)은 CS의 깊이보다 구현 가능한 정도가 더 중요할 수도 있다.",
    "mento_seed_id": "457273670840594980"
  },
  {
    "mento_seed_question": "페이지 구조화 시 position, flex, grid 사용법 알려줘.",
    "mento_seed_answer": "position 속성에 관한 차이를 분명하게 이해하고 있으면 어느 특정 화면 또는 요구 사항을 봤을 때 바로 판단이 선다. (많이 써보고 익숙해져야 한다.)",
    "mento_seed_id": "457273670840595339"
  },
  {
    "mento_seed_question": "프론트엔드 개발자가 읽으면 좋은 책",
    "mento_seed_answer": ": 켄트 백의 Tidy First : 소프트웨어 설계를 할 때 전체적인 시각 향상에 도움이 됨. 기본적으로 우리가 하는 프론트엔드 개발도 웹이라는 시스템에 속해있기 때문에 웹이라는 전체 시스템을 이해하는 것이 중요. 즉 전체 적인 시각을 많이 걸러야 나중에 편해짐.",
    "mento_seed_id": "457273670840595939"
  },
  {
    "mento_seed_question": "협업 과정에서 신입 개발자가 자주하는 실수",
    "mento_seed_answer": "사실상 신입은 당연히 실수를 한다고 봐야하고, 그런것들을 채워주고 더 나은 개발자가 될 수 있게 도와줄 수 있는 사수나 시니어를 만나는 것이 중요.",
    "mento_seed_id": "457273670840596048"
  },
  {
    "mento_seed_question": "(신입)취업 때 회사를 고르는 기준",
    "mento_seed_answer": "최소 본인 포함 4명이상의 개발자가 꾸려져있는 회사를 가는게 중요. 그리고 4명 중에 한명은 무조건 경력차이가 나는 리더가 있어야 함. 업무 환경이 그만큼 중요.",
    "mento_seed_id": "457273670840596066"
  },
  {
    "mento_seed_question": "`<a>` 태그와 `<button>` 태그 중 어떤 것을 선택할지 궁금합니다.",
    "mento_seed_answer": "요구사항에 맞춰서 사용자가 클릭액션을 통해 곧바로 다른 페이지로 이동하거나 액션을 취해야될 때는 a 태그를 사용해도 상관없지만, 중간에 다른 액션으로 나뉘어질 수 있는 경우의 수가 있을 때는 button으로 해결",
    "mento_seed_id": "457273670840596668"
  },
  {
    "mento_seed_question": "img 크기가 div를 넘어가는 이유와 해결법은?",
    "mento_seed_answer": "애초에 정해진 px이 있는 경우 상위 부모의 width, height 관계없이 벗어날 수 있음. 다만 %(퍼센트) 단위로 줬을때는 부모 기준으로 계산.",
    "mento_seed_id": "457273670840596732"
  },
  {
    "mento_seed_question": "`return`을 명시하지 않으면 `undefined` 반환 시 에러 발생 가능 여부",
    "mento_seed_answer": "애초에 undefined를 넘겨주는 것 자체가 의도일 수도 있기 때문에 잘못된 코드 작성법은 아님. 다만 대부분 해당 결과값 기준으로 분기처리를 할 때 if를 사용할텐데, if의 true, false 조건이 어떤 값들이 넘어 올 때 실행되는지를 정확하게 알고 있어야 함.",
    "mento_seed_id": "457273670840598447"
  },
  {
    "mento_seed_question": "포트폴리오 관리 방법은 무엇인가?",
    "mento_seed_answer": "노션을 많이 쓴다. 노션 같은 경우 url 공유 뿐만 아니라 pdf 형태로 뽑아낼 수 있는 기능도 있기때문에 여러 지원양식에 알맞다고 생각한다. 최대한 이미 잘 만들어져있는 도구를 쓰고, 본인들은 포트폴리오에 포함되는 프로젝트 퀄리티를 높이는데 시간을 투자하자.",
    "mento_seed_id": "457273670840600479"
  },
  {
    "mento_seed_question": "테스트코드의 중요성 및 종류는? \n\n요약: 테스트코드 중요성 및 종류",
    "mento_seed_answer": "한 때 TDD 열풍으로 마치 단위테스트는 모르면 안된다 라는 식의 기조가 있었는데 실제 현업에서 모두가 단위테스트를 열심히한다? 아니라고 본다. 프로젝트 진행상황마다 다르기 때문에 적합한 테스팅 도구를 선별하는 것이 좋다. 다만 프론트엔드 같은 경우 유저 입장에서의 사용성 테스트는 반드시 필요하기 때문에 개발자 선에서 E2E테스트를 굉장히 많이하고 있고, 만약 QA 팀이 있다면 별도로 그들의 TC에 맞게 진행한다면 더욱 좋은 퀄리티를 뽑아낼 수 있다.",
    "mento_seed_id": "457273670840600481"
  },
  {
    "mento_seed_question": "기본형 값들이 저장되는 메모리 (Stack vs Heap)",
    "mento_seed_answer": "number는 무조건 Stack에 저장..? --print-bytecode로 32bit가 넘는 number를 출력해보면 Constant Pool에 해당 값이 들어가고, Heap 영역에 저장됨.(Smi에 해당되지 않는 number들은 heap으로 넘어감) : SourceCode -> parser -> AST -> Ignition -> ByteCode -> JIT -> Assembly",
    "mento_seed_id": "457273670840600686"
  },
  {
    "mento_seed_question": "변수 메모리 주소값은 언제 저장되나요?",
    "mento_seed_answer": "JIT(+Turbo Fan)이 실행될때 실제 메모리 주소값을 생성하고 사용함.",
    "mento_seed_id": "457273670840600688"
  },
  {
    "mento_seed_question": "OpenGraph 썸네일 초기화가 안 될 때, 캐시 처리는 어떻게 해야 하나요?",
    "mento_seed_answer": ": 브라우저 Cache Storage가 존재하고, Cache란 이미지 등 큰 소스를 브라우저가 미리 가지고 있다가 필요 시 제공하는 것 : 브라우저 새로고침에 기본/강한/캐시를 초기화하면서 등의 방식이 있는데, 이때 기본 외 다른 방식으로 새로고침 하면 cache가 초기화된다.",
    "mento_seed_id": "457273670840600690"
  },
  {
    "mento_seed_question": "- var vs let vs const 차이",
    "mento_seed_answer": ": hoisting, scope, 재선언/재할당 등의 차이 : 값의 '재할당'은 엄밀이 말하면 값을 바꾼다라는 게 아니라, stack에 저장되어 있는 '주소값'을 바꾸는 것을 말한다.",
    "mento_seed_id": "457273670840600692"
  },
  {
    "mento_seed_question": "'화상면접'과 '대면면접' 중 어느 게 더 많아?",
    "mento_seed_answer": "코로나 이전에는 거의 대면이였는데, 이후 부터는 거의 대부분이 화상면접.",
    "mento_seed_id": "457273670840600756"
  },
  {
    "mento_seed_question": "js 기초 단계 어려움 극복에 도움되는 유튜브나 사이트가 있나요?",
    "mento_seed_answer": "기본적인 메서드나 코드 작성방법 등은 아무래도 반복적인 작업이 중요하다보니, 차라리 leetcode / codility같은 코딩테스트 연습 사이트에서 기본적인 문제를 반복해서 풀어보는 것 추천.",
    "mento_seed_id": "457273670840600766"
  },
  {
    "mento_seed_question": "프로젝트 템플릿이 취업에 미치는 영향에 대해 어떻게 생각하시나요?",
    "mento_seed_answer": "당연히 본인만의 프로젝트를 별도로 준비해야함. 부트캠프를 좋지않은 시선으로 보는 기업들이 있기 때문에 면접관의 인식을 바꾸려면 본인 스스로 100퍼센트 기여한 포트폴리오가 따로 있어야함.",
    "mento_seed_id": "457273670840600768"
  },
  {
    "mento_seed_question": "얕은복사, 깊은복사 차이",
    "mento_seed_answer": "2depth 이상 구조에서 테스팅. 깊은 복사 방법(JSON.stringify -> JSON.parse, structureCloned) 설명",
    "mento_seed_id": "457273670840600972"
  },
  {
    "mento_seed_question": "배열 리터럴 vs Array.prototype 생성자",
    "mento_seed_answer": "기능적으로는 크게 다른건 없고, new Array()로 배열 데이터를 생성하는 경우 초기 원소가 empty로 할당되기때문에 fill, map 같이 추가적으로 후처리가 필요함. 그래서 리터럴로 차라리 생성하는게 더 편함.",
    "mento_seed_id": "457273670840601147"
  },
  {
    "mento_seed_question": "원시타입 Wrapper Object(ex. String.prototype.length)",
    "mento_seed_answer": "원시타입 자체로는 length나 toLocalString이 당연히 없지만, 해당 프로퍼티를 선언했을 때 엔진 쪽에서 임시적으로 Wrapper Object(ex. new String)를 만들어서 기존에 호출한 프로퍼티에 대한 값을 넘겨주고, 호출이 끝나는 시점을 기준으로 GC에서 해당 Wrapper Object를 수거.",
    "mento_seed_id": "457273670840601149"
  },
  {
    "mento_seed_question": "TDD 프로젝트 도입 방법(jest)",
    "mento_seed_answer": "일단 제품 개발주기에 따라서 도입 여부부터 생각을 해봐야 함. 당장 다음주에 릴리즈를 해야되는 상황인 경우에는 TDD 도입은 말도 안되는 상황이고, 어느정도 여유가 있다면 TDD를 도입해서 팀내에서 정한 테스트 전략에 맞게끔 진행하면 됨. 도구는 그렇게 중요하지 않고, 지금 커리큘럼(미션) 단계에서 jest보다는 차라리 nodejs의 assert 모듈을 사용해서 간단한 테스팅 함수를 만들어가면서 테스트 하면 좋을 것 같음.",
    "mento_seed_id": "457273670840601502"
  },
  {
    "mento_seed_question": "개발자가 되기 전으로 돌아간다면 다시 개발자를 선택하실 건가요? 그 선택에 대한 이유도 말씀해주세요",
    "mento_seed_answer": "현재 기준으로는 개발자 말고는 다른 직업에 대한 메리트를 크게 못느끼는 상태라, 다시 돌아가더라도 할 것 같고 오히려 더 빨리 이 쪽 업계로 들어오지 않았을까.",
    "mento_seed_id": "457273670840601708"
  },
  {
    "mento_seed_question": "프로젝트 진행 중 팀원들과의 의견 조율 방법",
    "mento_seed_answer": "뻔한 답이겠지만, 싸우지말고 최대한 각자의 의견을 드러내면서 조율할 수 있는 부분을 빠르게 찾는게 관건. 그래서 채용공고를 보면 커뮤니케이션에 대한 내용이 많고, 의견 조율해야되는 상황이 생각보다 많음.",
    "mento_seed_id": "457273670840601710"
  },
  {
    "mento_seed_question": "백엔드 기본 소양의 범위",
    "mento_seed_answer": "클라이언트(브라우저, 모바일 디바이스 등)와 연동될 수 있는 백엔드의 기본적인 영역(Infra, WEB, WAS, DBMS)을 알야아하고, 각 영역별로 최소한 필요한 이유와 서로 연동하는 방법들에 대해서는 알아야 함.",
    "mento_seed_id": "457273670840601922"
  },
  {
    "mento_seed_question": "데이터 타입별 바이트 할당 크기",
    "mento_seed_answer": "Symbol 은 16바이트, String은 2~3바이트, 나머지는 4바이트가 기준",
    "mento_seed_id": "457273670840602027"
  },
  {
    "mento_seed_question": "함수 선언 방법에 따른 차이(선언식, 표현식, 화살표 함수)",
    "mento_seed_answer": "선언식 표현을 사용하면 호이스팅이 됨에 따라서 내가 함수를 선언하기도 전에 해당 함수를 호출하는 등의 코드 작성이 가능해짐. 하지만 어떻게보면 어떤 곳이든 작성만하면 실행 보장이 되다보니 원본 함수에 대한 추적이 힘들수 있고, 재선언이 가능하기 때문에 의도치 않은 동작이 덮어씌워져 오류가 발생할 수 있음. 호이스팅이 주는 편안함을 살짝 포기하고 안정성에 초점을 맞춘다면 표현식이나 화살표 함수 사용을 하는 것도 괜찮은 전략.",
    "mento_seed_id": "457273670840602233"
  },
  {
    "mento_seed_question": "React 상태관리 라이브러리 학습 방법",
    "mento_seed_answer": "기본적으로 Context-API를 통해 구현을 해보고, 문제점을 파악 한 뒤에 useSyncExternalStore를 이용한 상태관리, 그리고 zustand나 jotai를 추가적으로 다운받아서 학습해보면 좋음.",
    "mento_seed_id": "457273670840602281"
  },
  {
    "mento_seed_question": "기억에 남는 면접 질문",
    "mento_seed_answer": "면접을 본지가 좀 오래되서 잘 기억은 안나고, 대부분 기술적인 질문이라 참시한 질문이라고 한다면 내 기준에서는 인간 관점의 질문들일 듯. 추가적으로 면접관에게 기억에 남는 사람이 되고 싶다면 반대로 질문을 던지는 방향도 괜찮음.",
    "mento_seed_id": "457273670840602283"
  },
  {
    "mento_seed_question": "코드리뷰 주요 관점",
    "mento_seed_answer": "팀내 개발 컨벤션 유지 여부, 추후 유지보수 관점에서 효율성있게 작성되어있는 지, 현재 기준으로 에러를 일으킬 가능성이 높은 코드인지 등을 리뷰.",
    "mento_seed_id": "457273670840602285"
  },
  {
    "mento_seed_question": "예외처리 기준과 기법",
    "mento_seed_answer": "프론트엔드 기준에서는 UI, Network 두개 기준으로 먼저 예외처리를 하는 게 가장 일반적이고, 기법은 요구사항마다 처리해야될 케이스가 전부 다르기 때문에 설계서를 보고 추후에 판단하는게 중요.",
    "mento_seed_id": "457273670840602292"
  },
  {
    "mento_seed_question": "미디어 쿼리 내부 조건문에서 css 사용 가능 여부",
    "mento_seed_answer": "미디어쿼리는 JS Engine의 Parser에서 미리 평가를 해서 적용되는 부분이라 변수로 정의해둔 px 단위로 대입되는게 아니라 var( )가 그대로 대입됨.",
    "mento_seed_id": "457273670840602294"
  },
  {
    "mento_seed_question": "코드 오류 시, 새롭게 다시 짜는게 중요한지 아니면 오류가 난 부분을 고치는게 좋을지",
    "mento_seed_answer": "릴리즈(사용자 배포)가 얼마 남지 않은 기간에서는 사실 무조건 빠르게 기능이 돌아가는 쪽으로 선택을 해야하고, 현재 배우는 단계에서는 무조건적으로 오류가 난 부분을 수정하는 쪽으로 가야 실력이 향상됨. 오류를 고치면서 해당 오류의 원인과 해결방법들을 자연스럽게 습득하는 것이 매우 중요.",
    "mento_seed_id": "457273670840602318"
  },
  {
    "mento_seed_question": "개인프로젝트 시 고려해야 할 반응형 수준",
    "mento_seed_answer": "프로덕트의 성격을 고려해서 pc, 태블릿, 모바일 이렇게 나누겠지만, 현재 배우는 단계에서는 최대한 세밀한 기준으로 반응형을 나눠서 설계하는 게 실력 향상에 좋음. 그만큼 예외적인 상황들을 많이 만나기 때문에 그런 경험을 통해 추후에 같은 작업을 할 때 어느부분에서 오류가 날지, 혹은 어느 부분을 미리 해야할지 예측이 됨.",
    "mento_seed_id": "457273670840602320"
  },
  {
    "mento_seed_question": "nput같은 이벤트는 사용자가 한글자 입력할때마다 이벤트가 발생하니까, 실행에 부담이 되지는 않을까 궁금합니다(콜스택에 엄청 쌓인다거나, 타이밍이 꼬인다거나",
    "mento_seed_answer": "동기적인 관점에서는 사용자가 입력할 때마다 해당 이벤트와 같이 실행되는 코드가 많을수록 프레임이 밀릴 수 밖에 없음. 하지만 Debounce 같은 기법을 적용하게 되면 어느정도 해소가 가능하고, 비동기로 처리할 수 있게끔 한다거나, 워커(Worker)를 활용해서 메인스레드에 부담이 없게끔 할 수도 있긴 함. 하지만 지금 미션 수준에서는 걱정할 정도의 성능 누수는 없음.",
    "mento_seed_id": "457273670840602338"
  },
  {
    "mento_seed_question": "초보자가 유효성 검사 함수를 작성할 때 구조화하는 방법에 대한 조언을 구합니다.",
    "mento_seed_answer": "일단 나누는 기준이 가장 중요하고, 나눠서 작성했을 때 내가 아닌 다른 팀원들도 쉽게 파악이 가능하게끔 만들어야 함. 요구사항에 따라서 상세하게 나눠야하는 정도가 다를 수 있겠지만 현재 말한 기능들 같은 경우 Element를 정의하는 부분, Element에 이벤트를 붙이는 부분, 이벤트가 일어날때 실행되는 코어 로직 부분 이렇게 나눠볼 수 있음.",
    "mento_seed_id": "457273670840661241"
  },
  {
    "mento_seed_question": "AI 프로젝트 개발 시 AI API 활용 가능 여부와 유료 전환 기준 문의",
    "mento_seed_answer": "무조건은 아니고, 컨텐츠 특성상 AI 관련 기능이 들어갔을 때 자연스럽다고 하면 추가적으로 구현하면 되는 부분. 그리고 현재 수준에서 활용해볼만한 AI 기능들은 이미 공개된 LLM 서비스들을 api 형태로 사용하는게 가장 효과적임. 비용적인 문제는 ollama 같은 도구를 써서 로컬 서버에 설치해서 쓰게되면 별도의 AI api 비용 부담은 없고, 서버 비용만 부담하면 됨.",
    "mento_seed_id": "457273670840663657"
  },
  {
    "mento_seed_question": "자바스크립트 코드는 어떤 기준으로 나눠서 관리하시나요?",
    "mento_seed_answer": "프로젝트 기능에 따라 다르겠지만, 기본적으로 프론트엔드 같은 경우 UI와 API 통신을 하는 쪽 이렇게 크게 두부분부터 나누고, 요구사항을 분석해서 각 파트에서 더 상세하게 나누는 것이 가능.",
    "mento_seed_id": "457273670840663749"
  },
  {
    "mento_seed_question": "입력 오류 메세지 출력으로 인한 웹페이지 레이아웃 변화, 이를 수정하는 것이 좋을까요?",
    "mento_seed_answer": "이런 현상을 레이아웃 시프트라고 하는데, 최대한 수정하는 방향으로 가면 좋긴 함. 레이아웃 시프트가 일어나게되면 Element의 좌표나 크기 등이 바뀌기 대문에 Layout 단계를 다시 거치게 됨. 그렇게 되면 자연스럽게 Painting 단계를 또 지나가기 때문에 렌더링 엔진의 연산비용이 증가하게 됨.",
    "mento_seed_id": "457273670840663753"
  },
  {
    "mento_seed_question": "프론트엔드 개발자 취업 시장을 요약하면 '프론트엔드 개발자 취업 현황'입니다.",
    "mento_seed_answer": "최근 몇년간 IT 관련 교육기관들이 굉장히 많이 늘어났었기 때문에 공급이 워낙 많아졌고, 이로 인해 기업 입장에서는 비교적 더 좋은 인재를 선별할 수 있는 기회를 가지고 있는 상태. 그래서 이런 상황에 맞춰서 취업을 하기위해서는 당연하게도 같은 신입이더라도 신입같지 않은 수준으로 나아갈 수 있게끔 공부를 해야함.",
    "mento_seed_id": "457273670840663761"
  },
  {
    "mento_seed_question": "중점적으로 공부해야 할 내용 \n\n→ 공부해야 할 중점 내용",
    "mento_seed_answer": "실무에서 사용하는 대부분의 프론트엔드 기술들의 방향성을 보면 이미 단순히 '프론엔드' 영역만 있는 것이 아님. 그리고 프론트엔드 개발자가 실제 업무적으로 소화해야할 1인분의 범위가 단순히 비즈니스 로직 개발이 아닌 해당 산출물을 관리하고 실제 배포 프로세스에 포함시킬 수 있는 영역까지 가야하기 때문에 기본적인 백엔드, 인프라, CI/CD에 대한 역량은 당연히 필요함.",
    "mento_seed_id": "457273670840663769"
  },
  {
    "mento_seed_question": "Axios가 더 편리하다고 느껴지지만, Fetch를 사용하는 상황과 사용 비율이 궁금함.",
    "mento_seed_answer": "고도몰, 카페24 같은 내부 에디터에서 개발을 해야되는 상황이 아니라면 axios 라이브러리를 설치해서 사용. fetch에서는 네이티브로 직접 구현해야하는 기능들을 axios에서는 property와 method 형식으로 제공해주기 때문에 편함. 그리고 혹시나 크로스 브라우징을 고려했을 때도 axios 같은 경우 대응이 가능하고, 심지어 백엔드에서도 사용 가능. 다만, fetch로도 충분히 axios의 내장 기능들을 구현할 수 있기 때문에 지금 단계에서는 fetch로 한번씩 구현해보는 것이 좋은 경험이 될 것임.",
    "mento_seed_id": "457273670840663790"
  },
  {
    "mento_seed_question": "에러 메시지용 태그를 미리 만들기 vs 동적 생성으로 innerText 변경 중 무엇이 나을까?",
    "mento_seed_answer": "에러 발생하는 빈도에 따라서 결정. 빈도가 비교적 높다면 html 태그를 미리 생성해둔 상태로 레이아웃 시프트가 일어나지않게 width, height, padding, margin을 정해둠. 그리고 빈도가 낮다면 굳이 브라우저 입장에서 렌더링에 대한 부담을 줄이기 위해 동적으로 추가.",
    "mento_seed_id": "457273670840663796"
  },
  {
    "mento_seed_question": "테스트 코드를 평소에 작성하시는지? 한다면 어떤 테스트를 주로 작성하시는지? 그리고 테스트 코드의 가치에 대해서 개인적인 의견이 궁금합니다",
    "mento_seed_answer": "프로젝트 진행상황(배포 주기, 인적 리소스 등)에 따라서 테스트 코드 자체를 도입해야할지 말아야할지 정함. 테스트 코드를 반드시 도입해야하는 것은 아니며 기본적으로 QA 단계에서 최소한의 사용성 테스트는 진행되며, 애초에 프론트엔드 쪽에서는 테스트 코드가 모든 사용자 시나리오를 커버할 수 없음. 물론 충분한 리소스가 있고, 배포 주기가 넉넉하다면 당연히 장기적인 관점에서는 테스크 코드를 작성해서 유닛테스트, E2E테스트 실행을 통해 안정성을 높이는 방향은 좋음. 다만 테스트 코드에 너무 매몰되게 되면 테스트 코드를 작성하기 위한 비즈니스 코드를 작성하게 되는, 주객전도 현상이 올 수도 있으니 주의.",
    "mento_seed_id": "457273670840663831"
  },
  {
    "mento_seed_question": "리액트에서 자식 컴포넌트에서 부모 컴포넌트로 데이터를 넘겨주는 방식은 자주 사용하지 않는 방법인지, 아니면 피해야 할 방식인지 알고 싶습니다.",
    "mento_seed_answer": "기본적으로 나쁜 요구사항은 없음. 즉, 만약 요구사항대로 구현하기위해서 자식에서 부모로 상태를 넘겨주는 작업 자체가 피해야하는 방법은 절대 아님. 기술적으로는 부모 -> 자식, 자식 -> 부모 이렇게 자유롭게 상태를 넘겨줄 수 있어야 하고, 다만 컴포넌트 구조의 depth가 깊어졌을 때 Props Drilling을 통해서 상태를 넘겨주는 것은 되도록 지양해야 함",
    "mento_seed_id": "457273670840663837"
  },
  {
    "mento_seed_question": "state가 변경되어서, 이전 버추얼 돔과 새로 생성된 버추얼 돔을 비교하고, 실제 DOM을 업데이트하고나면 이전 버추얼 돔 은 그냥 삭제되는건가요?",
    "mento_seed_answer": "렌더링 때마다 메모리에서 새로운 Virtual DOM이 객체 형태의 데이터로 생성되고, 이전 상태와 현재 업데이트하려고 하는 상태를 비교해서 변경점이 있는 경우 Real DOM에 반영하기위해 변경 결과를 return 한다. 즉, 렌더링 때마다 계속 생성은 되겠지만 변경점이 있는 경우 Real DOM에 반영되지 않기 때문에 메모리 상에서만 연산이 일어난다. 그리고 Virtual DOM은 내부적으로 별도의 삭제 로직은 없고, 쓰여지지 않으면 GC가 자동으로 수집해가기 때문에 크게 소멸 시점은 신경쓸 필요 없음.",
    "mento_seed_id": "457273670840664052"
  },
  {
    "mento_seed_question": "성능 위주로 모니터링 할 수 있는 개발자 도구들",
    "mento_seed_answer": "Performance 탭을 기본적으로 활용하면 좋음. 예를 들면 우리가 흔히 DOM을 조작할 때 EventListener 를 여러개 붙여서 기능 구현을 하게 되는데 이럴 때 현재 페이지 기준에서 해당 리스너가 몇개나 붙었는지 그래프로 파악 가능. 또 스냅샷 기능으로 Heap 메모리를 얼마나 사용하고 있는지도 파악 가능.",
    "mento_seed_id": "457273670840664059"
  },
  {
    "mento_seed_question": "멘토님이 실무에서 겪은 가장 큰 버그나 장애가 무엇이었는지, 그리고 어떻게 해결하셨는지 궁금합니다!",
    "mento_seed_answer": "프레임워크에서 문제가 발생했을 때, 다른 프레임워크로 이동했던 적이 있음. 초창기에 너무 과하게 오버스펙으로 잡았던 문제때문에 이런 결과가 나왔고, 어떻게 보면 아키텍쳐 레벨로 바뀌는 부분이라서 엄청 큰 공수를 들여서 업데이트를 했음. 사실상 해결방법보다는 회고에 가깝긴하지만 프로젝트 시작 시, 요구사항들을 꼼꼼하게 확인하고 너무 과도한 스펙으로 구성하는 것은 나중에 큰 재앙(?)을 불러일으킬 수 있으니 조심.",
    "mento_seed_id": "457273670840664073"
  },
  {
    "mento_seed_question": "React에서 children prop은 일반적인 prop과 어떤 차이점이 있는지, 어떻게 사용되는지 궁금합니다.",
    "mento_seed_answer": "ReactElement 객체의 기본 prop으로 포함되어있는 객체이기 때문에 별도로 default 값을 선언할 필요 없음.(단, Typescript 환경에서는 PropsWithChildren을 상속받거나, 별도로 ReactNode 타입을 선언해줘야 함.) 이런 children prop은 합성 패턴을 적용해서 컴포넌트를 설계할 때 굉장히 많이 사용되므로 별도의 실습을 통해 children을 제어하는 것을 연습해보면 좋음. 그리고 React 패키지에서 네이티브로 제공하주는 'Children' API를 통해 좀더 세밀하게 children prop을 제어하는 것이 가능.",
    "mento_seed_id": "457273670840664079"
  },
  {
    "mento_seed_question": "`setState` 비동기 동작과 함수형 업데이트 필요 이유, `useRef`와 지역변수의 리렌더링 여부에 따른 `console.log` 동작 및 리렌더링 개념과 함수형 업데이트 불필요한 상황에 대해 알고 싶습니다.",
    "mento_seed_answer": "동기적으로 작동하는 코드라고 한다면 예를 들어 4, 5번 라인의 코드가 있다고 가정하고 4번 라인의 코드가 실행되고 결과까지 나왔을 때 5번이 실행되는 것을 의미. 비동기인 경우 4번 라인의 코드가 실행이 되고 결과가 나오지 않았음에도 불구하고 5번 라인의 코드가 이어서 실행되는 것을 의미. 그리고 React의 useState는 비동기로 동작하며 내부적으로 initialState를 기억하는 원리는 Javascript의 Closure 패턴을 사용하고 있기 때문에 가능. useState를 간단하게 JS로 구현해보면 오히려 쉽게 이해가 가능. useRef로 선언한 객체의 current 값은 React 컴포넌트의 상태가 변경되어서 리렌더링이 일어나더라도 초기화되지 않고 이전 값을 그대로 유지.",
    "mento_seed_id": "457273670840664318"
  },
  {
    "mento_seed_question": "팀 프로젝트 진행 전, 팀원들끼리 어떤 규칙을 정해야 할까요?",
    "mento_seed_answer": "파일구조(폴더 나누는 기준, 폴더명, 파일명 등)에 대한 컨벤션, 코드 레벨(변수명, 함수명 등)에서의 컨벤션 등이 미리 정해볼수 있는 컨벤션들이고, 프로젝트를 진행하다보면 이런 컨벤션을 맞춰야하는 케이스가 많아짐. 이럴 때마다 충분한 합의 과정을 통해서 결정해야 하고, 프로젝트 일정 등을 고려해서 합의에만 너무 많은 시간을 쏟아서 결정하는(과도한 민주주의) 형태만 피하면 됨.",
    "mento_seed_id": "457273670840664326"
  },
  {
    "mento_seed_question": "예약해둔 useEffect를 실행하면 Reconciliation이 한번 더 수행되는건가요?",
    "mento_seed_answer": "useEffect가 실행된다는 것은 이미 이전에 Reconciliation 작업에 의해 useEFfect가 dependencies로 참조하고 있는 상태가 바뀌었다는 것을 의미. 그리고 해당 useEffect 내부에서 또 상태를 업데이트 시키는 코드가 있다면 자연스럽게 Reconciliation을 또 진행.",
    "mento_seed_id": "457273670840664328"
  },
  {
    "mento_seed_question": "신입 개발자들이 실제 업무 준비 과정에서 느끼는 간극에 대한 현실적인 조언을 구합니다.",
    "mento_seed_answer": "경력직들도 마찬가지 기업에서 사람을 뽑는 것은 운이 많은 비중을 차지한다고 생각함. 그렇기 때문에 기회가 생기면(특히 지금같은 채용시장 상황인 경우) 무조건적으로 들어가봐야 함. 물론 너무 터무니 없는 조건이면 안됨. 그리고 기업 내부에서 이미 진행하고 있는 프로젝트에 참여하는 형태로 실무를 진행할 것이기 때문에 사전에 준비할 수 있는 부분이 거의 없다고 봐야함. 즉 들어가서 다시 해당 회사 개발팀의 컨벤션에 맞추는 작업은 당연히 필요하고 이를 보통 온보딩 기간이라고 함. 괴리감은 충분히 있을것이라고 생각은 하지만 자연스럽게 시간이 지나면 해결될 부분이라 미리 앞서서 걱정하는 것은 무의미.",
    "mento_seed_id": "457273670840664330"
  },
  {
    "mento_seed_question": "다음주면 첫 팀 프로젝트를 시작하게 되는데 역할 분담을 어떤식으로 하는게 좋을지, 협업하기 전 미리 정해두면 좋은 규칙이나 협업 방식이 있다면 조언 부탁 드립니다.",
    "mento_seed_answer": "초기 역할 분담은 각자의 강점을 살리는 방향으로 나누는 것이 좋음. 프론트/백 구분이 명확하면 자연스럽게 역할을 나눌 수 있지만, 모두가 프론트엔드라면 페이지 단위나 기능 단위(예: 로그인, 대시보드 등)로 나누는 것을 추천함. Git 브랜치 전략 (ex: main/dev/feature-xxx 식으로 관리) 커밋 메시지 컨벤션 (ex: [feat], [fix], [refactor] 같은 prefix 통일) 코드 스타일 (ex: 세미콜론 사용 여부, 탭/스페이스 설정) 파일/폴더 구조 (ex: 도메인 단위 or 페이지 단위) PR 리뷰 규칙 (ex: 1명 이상 승인 후 merge) 가장 중요한 것은 규칙을 정하는 데 과도한 시간을 쓰지 않는 것임. 기본적인 틀을 잡고 시작하고, 프로젝트를 진행하면서 필요한 부분을 유연하게 업데이트하는 것이 좋음. 일단 빠르게 시작하고 필요한 순간에 규칙을 보완하는 형태가 효율적임.",
    "mento_seed_id": "457273670840664336"
  },
  {
    "mento_seed_question": "퍼블리셔로 일했던 경험이 있다보니 실무에서 CSS 작업 비중이 어느정도 되는지, 얼만큼 깊이 있게 다루는지 궁금합니다.",
    "mento_seed_answer": "회사나 팀 성격에 따라 다르지만, 일반적인 프론트엔드 포지션에서는 CSS 작업 비중이 약 20~30% 정도 되는 경우가 많음. 단순 스타일 적용을 넘어 컴포넌트 기반으로 재사용성과 유지보수성을 고려한 스타일링이 중요하게 요구됨. CSS에 대한 실무 깊이는 대략 다음과 같음: 단순 스타일 적용 → 필수 기본기 디자인 시스템, 다크모드, 반응형 대응 → 실무 수준 렌더링 최적화, 접근성 고려 → 심화 영역 퍼블리셔 경험은 오히려 강점이 될 수 있음. 실무에서는 스타일링을 \"디자인 재현\"을 넘어 \"설계 관점\"으로 다루기 때문에, 기존 경험을 컴포넌트 단위 스타일링과 디자인 시스템 구축 관점으로 확장하면 충분히 경쟁력 있는 수준이 될 수 있음.",
    "mento_seed_id": "457273670840664340"
  },
  {
    "mento_seed_question": "React 버전 선택 시 어떤 기준을 우선해야 할까요? React 18이 실무에서 주로 사용되지만, React 19의 새로운 기능도 학습하고 싶습니다. 안정성과 새로운 기능 학습 중 무엇을 우선해야 하나요?",
    "mento_seed_answer": "팀 프로젝트에서는 안정성을 최우선으로 고려하는 것이 좋음. React 19는 아직 정식 출시 전 단계거나 초기 버전인 경우가 많기 때문에, 문서나 라이브러리 호환성에서 불안정할 수 있음. 실무 기준에서는 현재는 React 18이 가장 널리 사용되고 있음. 대부분의 실무 코드베이스도 React 18 기준으로 작성되어 있음. 팀 프로젝트 기준에서는 새로운 기능 학습은 개인적인 브랜치나 별도 테스트 프로젝트에서 진행하는 것이 좋음. 팀 전체의 프로젝트는 안정성과 완성도를 목표로 React 18을 사용하는 것이 적합함. 정리하면, 프로젝트는 React 18로 안정적으로 진행하고, React 19는 개인적으로 별도로 학습하는 방식을 추천함.",
    "mento_seed_id": "457273670840664631"
  },
  {
    "mento_seed_question": "Tailwind CSS와 Emotion 사용 시, 협업 효율성, 학습 효과, 실무 적용 가능성 측면에서 어떤 것이 더 도움이 되나요?",
    "mento_seed_answer": "팀 프로젝트에서는 Tailwind CSS를 추천함. 이유는 다음과 같음: 협업 효율성 → 클래스명으로 스타일을 빠르게 파악할 수 있어 협업에 유리함. 학습 효과 → Utility-First 방식의 설계를 경험할 수 있음. 실무 적용 가능성 → 최근 많은 기업들이 Tailwind CSS를 디자인 시스템, SaaS 프로젝트 등에 적극적으로 사용하고 있음. Emotion은 컴포넌트 단위 스타일링에 강점이 있고 자유도가 높지만, 스타일 관리 방식이 팀마다 달라질 수 있어 통일성 유지가 어려움. 따라서 첫 협업 경험이라면 Tailwind CSS를 사용하면서 명확한 스타일링 기준을 갖는 것이 성장에 더 도움이 됨.",
    "mento_seed_id": "457273670840664633"
  },
  {
    "mento_seed_question": "팀 프로젝트에서 CRUD 구현은 꼭 해보고 싶어서 선택했는데 이 외에 추가로 경험하면 좋은 기술이나 기능이 있을까요?",
    "mento_seed_answer": "CRUD 외에 추가로 경험하면 좋은 기능은 다음과 같음 Form Validation → 입력값 검증 (예: React Hook Form + Yup) Authentication → 로그인/회원가입, JWT 토큰 저장 및 인증 흐름 Pagination → 리스트를 페이지네이션 처리 Error Handling → API 실패 시 사용자에게 에러 메시지 표시 Optimistic UI → 데이터 조작 후 화면을 빠르게 업데이트 특히 실무에서는 단순 CRUD보다는 에러 핸들링, 인증, 페이지네이션이 자연스럽게 따라오므로, 가능하면 최소한 Form Validation + Authentication 정도는 함께 경험해보는 것을 추천함.",
    "mento_seed_id": "457273670840664635"
  },
  {
    "mento_seed_question": "효과적인 IT 개발 공부 방법이 궁금합니다.",
    "mento_seed_answer": "개발을 효과적으로 학습하는 가장 좋은 방법은 책이나 영상 강의만 보는 것이 아니라, 직접 무언가를 만들어보는 것. 단순히 개념을 이해하는 것에서 끝나는 것이 아니라, 직접 프로젝트를 진행하면서 개념을 체득하는 방식이 훨씬 더 강력한 학습 효과를 가져옴",
    "mento_seed_id": "457273670850861680"
  },
  {
    "mento_seed_question": "개발하다가 막힐 때 해결하는 방법이 궁금합니다.",
    "mento_seed_answer": "특정 문제에 너무 깊이 빠져들면, 오히려 해결 방법을 찾지 못하는 경우가 많음. 즉 문제를 오래 붙잡고 있다 보면, 같은 방식으로만 생각하게 되어 새로운 해결 방법을 떠올리기 어려워지는 현상이 발생함. 이럴 때는 잠깐 개발과 떨어져서 문제를 더 넓게 바라보는 것이 중요함.",
    "mento_seed_id": "457273670850861690"
  },
  {
    "mento_seed_question": "CSS 스타일링 방법을 보통 어떻게 진행하시나요?",
    "mento_seed_answer": "기존 사이즈 체계를 px 단위로 구성할지, rem 단위로 구성할지는 사실 정답이 없는 문제이긴하나 실무에서는 보통 rem단위로 진행을 많이하고, 별도로 rem에 대한 default px를 정하지않는 이상 16px 기준으로 정해져 있음. 다만 브라우저 상의 px 사이즈와 피그마의 px 사이즈 차이가 다소 있을 수 있기 때문에 디자이너와 협업할 때는 이 부분을 이해시키는게 중요.",
    "mento_seed_id": "457273670850863041"
  },
  {
    "mento_seed_question": "CSS 속성에 순서가 존재하는가?",
    "mento_seed_answer": ": 만약 순서를 어떻게 짜느냐 따라 렌더링 성능이 달라진다고 하면 중요하겠지만, 그렇지 않으니 중요한 건 아님 : 성능과 관계 없이, 개발 편의성을 위해 프로젝트 컨벤션(규칙)을 따르는 것임 : 기술 면접 때 100% \"브라우저 렌더링 과정\"이 나올 것 (해당 내용은 반드시 공부할 것)",
    "mento_seed_id": "457273670850864102"
  },
  {
    "mento_seed_question": "코딩테스트 준비 어떻게 하나요",
    "mento_seed_answer": "취업 준비방향은 코딩테스트를 준비하거나, 사전과제를 준비하거나 둘중에 하나로 결정되는데, 만약 코딩테스트(알고리즘 테스팅)를 준비한다고 한다면 알고리즘에 대한 간략한 강의를 먼저보고 문제를 많이 풀어보는 것을 추천.",
    "mento_seed_id": "457273670850864745"
  },
  {
    "mento_seed_question": "좋은 코드라고 생각하는 기준",
    "mento_seed_answer": ": 협업 관점에서는 누가 봐도 빠른 시간안에 이해할 수 있는 코드(변수 & 함수의 적절한 네이밍, 재사용성 증가, 관심사 분리 등)를 작성하거나, 성능 관점에서는 최대한 메모리를 작게 쓰면서 빠른 시간안에 코드를 실행하는 것",
    "mento_seed_id": "457273670850864863"
  },
  {
    "mento_seed_question": "html 작성 시 깔끔하고 효율적으로 작성하는 방법 알려줘.",
    "mento_seed_answer": "공통 레이아웃 중심으로만 html 파일에서 태그로 정의하고, 페이지마다 필요한 내부적인 레이아웃은 JS 파일을 통해 핸들링.",
    "mento_seed_id": "457273670850865145"
  },
  {
    "mento_seed_question": "\"좋은 커밋 메세지 작성법\"",
    "mento_seed_answer": "메시지만 봐도 어떤 코드들이 들어있고, 해당 코드에 대해서 어떤 작업을 했는 지 알 수 있게 끔 작성하는게 제일 좋다고 함.",
    "mento_seed_id": "457273670850865577"
  },
  {
    "mento_seed_question": "개발자 처우를 31자 이내로 요약하면 '개발자 처우'입니다.",
    "mento_seed_answer": "당연하겠지만 회사마다 다를것이고, 기존에 본인이 다른 회사에서 일을 해봤다면 그 회사 신입 기준으로 생각해보면 좋을 것 같고, 나눠줬던 장표들을 보고 실제 초봉선이 이정도 된다고 파악만 하면 좋을듯 하다. 신입이라도 연봉협상이 가능한 케이스가 있기 때문에 너무 고정적인 테이블로 간다는 생각은 버리는 게 좋다.",
    "mento_seed_id": "457273670850869727"
  },
  {
    "mento_seed_question": "프로젝트 코드 포맷팅 셋업 방법을 알고 싶습니다.",
    "mento_seed_answer": "eslint, prettier 같은 경우 팀단위로 프로젝트를 진행할 때 필수적으로 맞춰야 하고, 안맞췄을 경우에 현 시점 기준으로 가장 빠르게 마주할 상황은 git conflict다. 사실상 이런 conflict를 먼저 겪어보고 포맷팅 도구들을 셋업하면 더 필요성을 느끼고 공부를 하겠지만, 일단 지금이라도 알았으니 최대한 프로젝트 시작 전에 먼저 맞추고 들어가자.",
    "mento_seed_id": "457273670850869729"
  },
  {
    "mento_seed_question": "코드 작성 시에 꼭 지키는 나만의 설계 방법",
    "mento_seed_answer": "최대한 유연하고, 확장성있게 설계하는 것이 중요. 우리가 만드는 것의 대부분이 소프트웨어이고 특성상 쉽게 변한다. 그렇기 때문에 변화에 유동적으로 대응하기 위해서는 코드를 느슨하게 작성하는 것이 좋다. 물론 결합도가 높아야되는 케이스도 있겠지만, 거의 대부분은 느슨하게 설계하는 편이다.",
    "mento_seed_id": "457273670850869731"
  },
  {
    "mento_seed_question": "B2C 기업들이 프로덕트 기준을 모바일로 확장하나?",
    "mento_seed_answer": ": 기본적으로 모바일 시장이 커지면서 B2C 기업들은 모바일 퍼스트, 그리고 나머지 디바이스에 대한 레이아웃을 반응형으로 확장하는 방식.",
    "mento_seed_id": "457273670850869956"
  },
  {
    "mento_seed_question": "합격 여부 통보 안해주면 불합격인가요?",
    "mento_seed_answer": "지원 기업마다 시기는 다르겠지만, 통보는 확실히 해주는 편. 평균적으로 1~2주 내로는 거의 연락이 오는 편.",
    "mento_seed_id": "457273670850869967"
  },
  {
    "mento_seed_question": "이력서에 사용하는 증명사진은 필수인가요?",
    "mento_seed_answer": "필요로하는 지원서가 있다면 반드시 해주자. 최소한의 인사팀에 대한 예의",
    "mento_seed_id": "457273670850870282"
  },
  {
    "mento_seed_question": "컬쳐핏은 확인은 어떤식으로 하나요?",
    "mento_seed_answer": "서로의 업무 스타일을 얘기하고, 현재 팀이 원하는 목표에 대해서 설명하고 이해할 수 있는 지, 그리고 레퍼체크를 하는 경우도 있음.",
    "mento_seed_id": "457273670850870286"
  },
  {
    "mento_seed_question": "'부업으로 멘토링 하는 이유는?'",
    "mento_seed_answer": "당연히 1차적으로는 돈, 그리고 머릿속으로만 알고 있던 지식에 대한 검증",
    "mento_seed_id": "457273670850870290"
  },
  {
    "mento_seed_question": "부트캠프 강사로 활동하며 가장 기억에 남는 학생은?",
    "mento_seed_answer": "3년차때 일인데, 3개월 공부한 수강생이 훨씬 더 잘하고, 심지어 굉장히 젠틀. 그냥 인간적으로 봤을 때 나보다 훨씬 성숙하고 지능 높은 사람이였음.",
    "mento_seed_id": "457273670850870294"
  },
  {
    "mento_seed_question": "개발자로 일하면서 어떤 점이 좋았고 어떤 점이 아쉬우셨나요?",
    "mento_seed_answer": "가끔씩 개발자 뽕이 차있는 사람들이 있는데, 뭔가 개발자라서 일반사람들과 대화가 잘 안되는 모습들...? 그런 모습들이 보일때마다 참 아쉽다고 생각함. 그리고 우리는 업무 특성상 절대 main이 될 수 없고, main을 디지털로 받치는 sub의 역할이 대부분이라는 것을 명심.",
    "mento_seed_id": "457273670850870296"
  },
  {
    "mento_seed_question": "window event 객체, (+ Capturing, Bubbling)",
    "mento_seed_answer": "브라우저 내에서 일어나는 모든 이벤트는 window로 전파. (=> window.event), 그렇기 때문에 이벤트 핸들러 함수에서 인자 없이 event로도 방금 일어난 이벤트 객체에 접근 가능.",
    "mento_seed_id": "457273670850870636"
  },
  {
    "mento_seed_question": "MSW(Mock Service Worker) 활용 케이스",
    "mento_seed_answer": "브라우저의 Service Worker에 등록되어 있는 더미데이터 기준으로 network 통신 테스트를 하는 라이브러리이고, 백엔드 API 서버가 아직 셋업이 안되어있거나 초기 프로젝트 셋업때부터 api 통신 테스트용으로 주로 활용.",
    "mento_seed_id": "457273670850870747"
  },
  {
    "mento_seed_question": "면접 준비 방법",
    "mento_seed_answer": "신입 개발자에게 물어볼 수 있는 범위라고 하면, 포트폴리오 + 기본 CS, 웹 지식 정도이고 여기서 공통적인 부분(cs, 웹)은 사실상 암기식으로 외워서 답하는 경우가 대부분이라 다른 지원자들과 차별점을 두기는 어려움. 그렇기때문에 포트폴리오에서 내가 기여한 기능 부분 관련해서 심도 있게 고민했던 부분이나, 해당 기능 개발을 통해 배운 경험들을 이야기하는 것이 더 중요.",
    "mento_seed_id": "457273670850871459"
  },
  {
    "mento_seed_question": "bytecode 출력",
    "mento_seed_answer": "node --print-bytecode를 통해서 현재 작성한 Source Code가 어떤 Bytecode 형태로 변환되고, 해당 Bytecode 분석을 통해서 엔진에서 해당 코드를 실행하기 위해 필요한 byte 크기와 프레임사이즈, 각 데이터가 Stack에 Lda 되는지 혹은 Heap에 Lda되는지 알 수 있음.",
    "mento_seed_id": "457273670850871772"
  },
  {
    "mento_seed_question": "파일 구조 관리 방법",
    "mento_seed_answer": "현재 진행하는 미션 기준으로 봤을 때는 간단하게 페이지 별로 폴더를 만들고, 해당 폴더에서 html, css, js 레이어 별로 파일을 관리하는게 가장 기본적인 방법. 추후에 기술스택 구조에 따라서 파일 구조화 방식이 달라지기 때문에 나중에 생각.",
    "mento_seed_id": "457273670850871775"
  },
  {
    "mento_seed_question": "상위 객체(window, document, body)의 Event Listener 활용 사례",
    "mento_seed_answer": "요구사항 따라서 수많은 경우가 나오겠지만, 일단 아래 이벤트를 주로 활용 [window] : load, beforeunload, resize [document] : DOMContentLoaded [script] : load",
    "mento_seed_id": "457273670850871970"
  },
  {
    "mento_seed_question": "취업 포트폴리오 선정 기준",
    "mento_seed_answer": "자기소개 웹사이트를 포트폴리오로 넣는다고 해서 더 가산점이 있지는 않음. 다만 어쨌든 본인이 해왔던 작업물들을 웹사이트나 pdf파일로는 가지고 있어야하기 때문에 필요는 함.",
    "mento_seed_id": "457273670850872081"
  },
  {
    "mento_seed_question": "CS 공부 방법",
    "mento_seed_answer": "javascript의 기본적인 이론을 공부하다 보면 무조건적으로 CS와 겹치는 부분이 생김. 예를 들면 원시타입과 참조타입 공부를 할때 해당 데이터들이 Stack, Heap에 저장된다는 것을 알고 있고, Stack과 Heap은 CS의 자료구조에 해당되기 때문에 같이 공부를 하게되면 Javascript + CS가 됨.",
    "mento_seed_id": "457273670850872083"
  },
  {
    "mento_seed_question": "효율적인 자바스크립트 학습 방법",
    "mento_seed_answer": "요구사항을 보고 어떤 Method를 쓰고, 어떤 자료구조로 셋업을 해야되는지 바로 알고 싶다면 문제를 많이 풀어보는 방향이 좋음. 보통 코딩테스트 사이트의 저수준 문제들을 다양하게 풀어보면 도움이 많이 됨.",
    "mento_seed_id": "457273670850872085"
  },
  {
    "mento_seed_question": "png, webp, svg 각각 확장자의 차이",
    "mento_seed_answer": "일단 기본적으로 래스터 이미지, 벡터 이미지의 차이를 먼저 아는게 중요하고, webp같은 경우 브라우저에서 이미지 로딩을 사용자게에 좀더 빠르게 하기 위해 준비된 확장자로, 기본 이미지 용량대비 60퍼센트로 다운로드를 진행함.",
    "mento_seed_id": "457273670850872087"
  },
  {
    "mento_seed_question": "개인 프로젝트 주제는 선정 방법",
    "mento_seed_answer": "본인이 필요한 기능위주의 웹사이트를 만들어도 되고, 취업에 포커스를 좀더 맞춘다면 희망하는 기업들의 도메인을 분석해서 해당 도메인을 주제로 하는 웹사이트를 만들어보는 것도 좋은 전략.",
    "mento_seed_id": "457273670850872097"
  },
  {
    "mento_seed_question": "프로젝트 진행 시 가장 우선적으로 해야되는 작업들",
    "mento_seed_answer": "무조건적으로 기획과 설계, 이유는 개발할 때마다 자칫 방향을 잃기 쉬운데 그 때마다 이정표 역할을 해줄것이고 방향성을 제대로 잡아야 중간에 변경사항이나 오류가 생기더라도 빠르게 수정해서 개발을 진행할 수 있음.",
    "mento_seed_id": "457273670850872099"
  },
  {
    "mento_seed_question": "팀 프로젝트 평가 시 '통일성'과 '컨벤션'을 확인하나요? 마찰을 감수하고 강행해야 하나요?",
    "mento_seed_answer": "개인 프로젝트가 아닌 이상 컨벤션을 맞추는 작업은 굉장히 중요함. 그리고 처음 컨벤션을 정할 때 충분히 팀원들과 논의를 하고, 애초에 생각이 같을 수가 없기 때문에 다수의 의견에 따라서 컨벤션을 지키자던지 이런 별도의 룰은 필요함(이게 안되면 프로젝트 진행이 안됨).",
    "mento_seed_id": "457273670850937511"
  },
  {
    "mento_seed_question": "ES모듈과 CommonJS모듈은 어떤 차이가 있는건가요?",
    "mento_seed_answer": "일단 ESM, CJS의 차이를 알기 위해서는 정적분석 가능 여부를 파악해야하고, 정적분석이 어떤 것을 의미하는지 공부를 해봐야 함.",
    "mento_seed_id": "457273670850937513"
  },
  {
    "mento_seed_question": "package.json파일은 왜 필요하며 어떤 내용이 담기나요?",
    "mento_seed_answer": "NodeJS 기반의 프로젝트를 앞으로 진행할 때, 해당 프로젝트의 명세서라고 보면 된다. 어떤 라이브러리, 프레임워크에 의존하고 있는지, 프로젝트를 실행시키는 명령어가 어떻게 구성되어있지는, 프로젝트 오너와 참고 url은 무엇인지 등 여러가지 정보를 담고 있음.",
    "mento_seed_id": "457273670850937515"
  },
  {
    "mento_seed_question": "js에서 가독성 = 최적화 ? 예를 들어 if문 대신 ? : 조건연산자나 ?. 옵셔널 체이닝을 이용하는게 좋을까요?",
    "mento_seed_answer": "if문에서 일어나는 모든 케이스를 삼항연산자나, 옵셔널 체이닝으로 대체하는 것이 애초에 불가능. 대체제로 인식할게 아님. 분기처리해야될 케이스가 많은 경우, 삼항연산자를 통해서 코드를 작성하게되면 오히려 가독성이 떨어짐. 그리고 특정 조건에서 undefined가 아닌 다른 값을 return 해야하는 경우 옵셔널 체이닝으로는 해당 기능 구현이 불가능.",
    "mento_seed_id": "457273670850937521"
  },
  {
    "mento_seed_question": "React의 현업 버전과 학습 우선순위를 어떻게 설정해야 하는지 알려주세요.",
    "mento_seed_answer": "최소 17버전을 사용할 것이고, 대부분 18버전에 머물러 있을 것임. 기본적으로 프레임워크 레벨에서의 버전 이동은 쉽지가 않음. 기존에 쌓여있던 레거시 코드들도 호환성을 생각해야되기 때문에 무리하게 버전업을 했을 때 일어나는 사이드 이펙트를 감당해야되는 공수가 생김.",
    "mento_seed_id": "457273670850937550"
  },
  {
    "mento_seed_question": "여러 유사한 라이브러리 중 어떤 기준(npm trends, 문서화, API 직관성 등)을 바탕으로 선택하는지 알고 싶음.",
    "mento_seed_answer": "요구사항에 맞는 기능을 라이브러리 도움없이 구현이 불가능한 수준이거나, 혹은 너무 많은 공수가 들어가는 경우에는 라이브러리를 사용함. 즉 생산성을 챙겨야하는 상황이면 라이브러리 도입을 고려하는 편. 하지만 프론트 같은 경우 무분별한 라이브러리 도입을 하는 경우 빌드타임 비용 증가, 앱사이즈 증가로 인한 사용성 저하 부분이 일어나기때문에 항상 고민을 하는 부분. 나머지 선택 기준은 문서화가 확실하게 잘 되어있으면 좋고, 관리주체가 확실한지를 살펴보는 편.",
    "mento_seed_id": "457273670850937552"
  },
  {
    "mento_seed_question": "리액트 프로젝트를 시작할 때 기본적인 디렉터리 구조는 어떻게 잡는 것이 좋은지, 코드 가독성을 높이기 위해 처음 배울때 알고있으면 좋을만한 팁이 있는지 궁금합니다.",
    "mento_seed_answer": "파일구조를 생각할 때는 프로젝트 요구사항을 구현하기 필요한 것들을 군집화하는 것이 중요. 가시적인 관점에서 크기 순으로 봤을 때 페이지 컴포넌트(/pages), 페이지 컴포넌트 내부를 구성하는 하위 컴포넌트들(/components), 각 컴포넌트들에서 사용하는 일반 함수(/utils), 각 컴포넌트들에서 상태관리를 위해 참조하는 커스텀 훅(/hooks) 등이 있다. 크게는 이렇게 잡고 나머지 필요한 부분들은 각 폴더에서 또 하위로 나눠서 관리하면 좋음. 추후에 이런 기본적인 구조가 익숙하다면 FSD 아키텍처를 공부해서 다시 파일구조를 셋업해보는 것도 중요. 제일 중요한 점은 어떤 구조를 사용하던지 간에 본인 뿐만 아니라 팀원들이 해당 파일 구조를 봤을 때 '이 파일, 폴더에는 이게 있겠구나~' 라고 예상을 할 수 있어야 함.",
    "mento_seed_id": "457273670850937590"
  },
  {
    "mento_seed_question": "React에서 `setState` 사용시, 기존 배열을 직접 수정하면 안 되는 이유와 `spread` 연산자 사용의 효율성에 대한 궁금증입니다.",
    "mento_seed_answer": "Spread 연산자를 사용해서 기존 객체 형태의 상태를 copy하는 이유는 React가 내부적으로 가지고 있는 '불변성' 메커니즘을 따라가기 위해서임. 물론 1차원 Depth에서 가능한 케이스고, 내부에 원시타입이 아닌 또다른 객체나 배열이 존재하면 다른 copy 방법을 써야함. 그렇기 때문에 Spread 연산자만 사용하는 것이 아닌 상황별로 다양한 불면성을 지키면서 copy하는 방법을 알아야 함. JSON.stringify -> JSON.parse를 통해서 진행하거나 structuredClone 을 통해서 copy를 할 수도 있음. 그리고 물론 copy 해야하는 객체의 depth 깊을수록 JSON 방법은 좋지 않음.",
    "mento_seed_id": "457273670850937844"
  },
  {
    "mento_seed_question": "프로젝트 셋업 branch 관리 방법",
    "mento_seed_answer": "팀내 관리 방법에 따라가면 될 것 같음. main으로 기본적인 파일구조나 라이브러리 셋업을 해놓고 develop으로 파생시킬 수도 있고, 아니면 main을 애초에 비워두고 develop부터 셋업해서 feature로 파생시키는 방법도 있음. 둘다 기능적으로 크게 영향이 있는 부분은 아니라 선택하기 나름.",
    "mento_seed_id": "457273670850937858"
  }
]
